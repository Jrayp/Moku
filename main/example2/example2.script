local moku = require "moku.moku"

local get_coords

function init(self)

    msg.post("@render:", "clear_color", { color = vmath.vector4(.5, .5, .5, 0) } )

    -- Handle initial map and autotiling
    local tile_ids = {
        WALL = 1,
        SLOW_ZONE = 17,
        FLOOR = 33
    }

    self.astar_map = moku.new_from_tm("astar_map#example2_tm", "layer1", 32, 32)

    moku.set_autotile(self.astar_map, tile_ids.WALL, moku.at_algorithm.SIMPLE, true, false, false)
    moku.set_autotile(self.astar_map, tile_ids.SLOW_ZONE, moku.at_algorithm.SIMPLE, true, false, true)

    self.astar_map.tile_ids = tile_ids

    moku.autotile_map(self.astar_map)

    msg.post(".", "acquire_input_focus")

    moku.init_pathfinder(self.astar_map)

    self.start_cell = self.astar_map[ - 18][ - 13]
    self.end_cell = self.astar_map[19][14]

    self.astar_map.pathfinder = {
        search_limit = -1,
        allowed_directions = moku.dir_tables.ALL,
        punish_direction_change = true,
        punish_direction_change_penalty = 5,
        heavy_diagonals = true,
        heavy_diagonals_multiplier = 2.41
    }

    local path, _ = moku.find_path(self.astar_map, self.start_cell, self.end_cell)

    self.path = path

end

function on_input(self, action_id, action)
    if action_id == hash("left_click") then
        local cx, cy = get_coords(self, action.x, action.y)
        if cx and cy then
            self.astar_map[cx][cy].tile_id = self.astar_map.tile_ids.WALL
            moku.autotile_surrounding(self.astar_map, cx, cy)
            self.path = moku.find_path(self.astar_map, self.start_cell, self.end_cell)
        end
    elseif action_id == hash("ctrl") then
        local cx, cy = get_coords(self, action.x, action.y)
        if cx and cy then
            self.astar_map[cx][cy].tile_id = self.astar_map.tile_ids.FLOOR
            moku.autotile_surrounding(self.astar_map, cx, cy)
            self.path = moku.find_path(self.astar_map, self.start_cell, self.end_cell)
        end
    elseif action_id == hash("shift") then
        local cx, cy = get_coords(self, action.x, action.y)
        if cx and cy then
            self.astar_map[cx][cy].tile_id = self.astar_map.tile_ids.SLOW_ZONE
            moku.autotile_surrounding(self.astar_map, cx, cy)
            self.path = moku.find_path(self.astar_map, self.start_cell, self.end_cell)
        end
    elseif action_id == hash("s") then
        local cx, cy = get_coords(self, action.x, action.y)
        if cx and cy then
            self.start_cell = self.astar_map[cx][cy]
            self.path = moku.find_path(self.astar_map, self.start_cell, self.end_cell)
        end
    elseif action_id == hash("e") then
        local cx, cy = get_coords(self, action.x, action.y)
        if cx and cy then
            self.end_cell = self.astar_map[cx][cy]
            self.path = moku.find_path(self.astar_map, self.start_cell, self.end_cell)
        end
    end
end

function get_coords(self, mx, my)
    -- Get the camera position
    local cam_pos = go.get_position("camera_go")

    -- Calculate the relative world coords
    local wx = mx + cam_pos.x
    local wy = my + cam_pos.y

    return moku.pick_coords(self.astar_map, 0, 0, wx, wy)
end

function update(self, dt)

    if self.path then
        for i = 1, #self.path - 1 do
            local cc = self.path[i]
            local nc = self.path[i + 1]
            local sx, sy = moku.cell_center(self.astar_map, 0, 0, cc.moku_x, cc.moku_y)
            local ex, ey = moku.cell_center(self.astar_map, 0, 0, nc.moku_x, nc.moku_y)
            local s = vmath.vector3(sx, sy, - 1)
            local e = vmath.vector3(ex, ey, - 1)

            msg.post("@render:", "draw_line", { start_point = s, end_point = e, color = vmath.vector4(1, .3, 0, 0) } )
        end
    end

end
